!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ACCESS_CONTROL_LIST	mongoose.c	/^  ACCESS_CONTROL_LIST, ACCESS_LOG_FILE, AUTH_DOMAIN, CGI_INTERPRETER,$/;"	e	enum:__anon1	file:
ACCESS_LOG_FILE	mongoose.c	/^  ACCESS_CONTROL_LIST, ACCESS_LOG_FILE, AUTH_DOMAIN, CGI_INTERPRETER,$/;"	e	enum:__anon1	file:
AR	Makefile	/^AR = ar rc$/;"	m
ARRAY_SIZE	mongoose.c	128;"	d	file:
AUTH_DOMAIN	mongoose.c	/^  ACCESS_CONTROL_LIST, ACCESS_LOG_FILE, AUTH_DOMAIN, CGI_INTERPRETER,$/;"	e	enum:__anon1	file:
CC	Makefile	/^CC = gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS = -I..\/include$/;"	m
CGI_ENVIRONMENT_SIZE	mongoose.c	133;"	d	file:
CGI_INTERPRETER	mongoose.c	/^  ACCESS_CONTROL_LIST, ACCESS_LOG_FILE, AUTH_DOMAIN, CGI_INTERPRETER,$/;"	e	enum:__anon1	file:
CGI_PATTERN	mongoose.c	/^  CGI_PATTERN, DOCUMENT_ROOT, ENABLE_DIRECTORY_LISTING, ERROR_LOG_FILE,$/;"	e	enum:__anon1	file:
CONN_CLOSE	mongoose.c	/^enum connection_flags { CONN_CLOSE = 1, CONN_SPOOL_DONE = 2, CONN_SSL = 4 };$/;"	e	enum:connection_flags	file:
CONN_SPOOL_DONE	mongoose.c	/^enum connection_flags { CONN_CLOSE = 1, CONN_SPOOL_DONE = 2, CONN_SSL = 4 };$/;"	e	enum:connection_flags	file:
CONN_SSL	mongoose.c	/^enum connection_flags { CONN_CLOSE = 1, CONN_SPOOL_DONE = 2, CONN_SSL = 4 };$/;"	e	enum:connection_flags	file:
DAV_AUTH_FILE	mongoose.c	/^  INDEX_FILES, LISTENING_PORT, DAV_AUTH_FILE, RUN_AS_USER,$/;"	e	enum:__anon1	file:
DBG	mongoose.c	144;"	d	file:
DBG	mongoose.c	147;"	d	file:
DIR	mongoose.c	/^typedef struct DIR {$/;"	s	file:
DIR	mongoose.c	/^} DIR;$/;"	t	typeref:struct:DIR	file:
DIR::handle	mongoose.c	/^  HANDLE   handle;$/;"	m	struct:DIR	file:	access:public
DIR::info	mongoose.c	/^  WIN32_FIND_DATAW info;$/;"	m	struct:DIR	file:	access:public
DIR::result	mongoose.c	/^  struct dirent result;$/;"	m	struct:DIR	typeref:struct:DIR::dirent	file:	access:public
DOCUMENT_ROOT	mongoose.c	/^  CGI_PATTERN, DOCUMENT_ROOT, ENABLE_DIRECTORY_LISTING, ERROR_LOG_FILE,$/;"	e	enum:__anon1	file:
ENABLE_DIRECTORY_LISTING	mongoose.c	/^  CGI_PATTERN, DOCUMENT_ROOT, ENABLE_DIRECTORY_LISTING, ERROR_LOG_FILE,$/;"	e	enum:__anon1	file:
ENV_EXPORT_TO_CGI	mongoose.c	135;"	d	file:
EP_CGI	mongoose.c	/^enum endpoint_type { EP_NONE, EP_FILE, EP_CGI, EP_USER, EP_PUT };$/;"	e	enum:endpoint_type	file:
EP_FILE	mongoose.c	/^enum endpoint_type { EP_NONE, EP_FILE, EP_CGI, EP_USER, EP_PUT };$/;"	e	enum:endpoint_type	file:
EP_NONE	mongoose.c	/^enum endpoint_type { EP_NONE, EP_FILE, EP_CGI, EP_USER, EP_PUT };$/;"	e	enum:endpoint_type	file:
EP_PUT	mongoose.c	/^enum endpoint_type { EP_NONE, EP_FILE, EP_CGI, EP_USER, EP_PUT };$/;"	e	enum:endpoint_type	file:
EP_USER	mongoose.c	/^enum endpoint_type { EP_NONE, EP_FILE, EP_CGI, EP_USER, EP_PUT };$/;"	e	enum:endpoint_type	file:
ERROR_LOG_FILE	mongoose.c	/^  CGI_PATTERN, DOCUMENT_ROOT, ENABLE_DIRECTORY_LISTING, ERROR_LOG_FILE,$/;"	e	enum:__anon1	file:
EXTRA_HTTP_HEADERS	mongoose.c	140;"	d	file:
EXTRA_MIME_TYPES	mongoose.c	/^  EXTRA_MIME_TYPES, GLOBAL_AUTH_FILE, HIDE_FILES_PATTERN, IDLE_TIMEOUT_MS,$/;"	e	enum:__anon1	file:
F1	mongoose.c	2295;"	d	file:
F2	mongoose.c	2296;"	d	file:
F3	mongoose.c	2297;"	d	file:
F4	mongoose.c	2298;"	d	file:
GLOBAL_AUTH_FILE	mongoose.c	/^  EXTRA_MIME_TYPES, GLOBAL_AUTH_FILE, HIDE_FILES_PATTERN, IDLE_TIMEOUT_MS,$/;"	e	enum:__anon1	file:
HEXTOI	mongoose.c	983;"	d	file:
HIDE_FILES_PATTERN	mongoose.c	/^  EXTRA_MIME_TYPES, GLOBAL_AUTH_FILE, HIDE_FILES_PATTERN, IDLE_TIMEOUT_MS,$/;"	e	enum:__anon1	file:
IDLE_TIMEOUT_MS	mongoose.c	/^  EXTRA_MIME_TYPES, GLOBAL_AUTH_FILE, HIDE_FILES_PATTERN, IDLE_TIMEOUT_MS,$/;"	e	enum:__anon1	file:
INDEX_FILES	mongoose.c	/^  INDEX_FILES, LISTENING_PORT, DAV_AUTH_FILE, RUN_AS_USER,$/;"	e	enum:__anon1	file:
INT64_FMT	mongoose.c	106;"	d	file:
INT64_FMT	mongoose.c	65;"	d	file:
INVALID_SOCKET	mongoose.c	105;"	d	file:
IOBUF_SIZE	mongoose.c	130;"	d	file:
LIB	Makefile	/^LIB = ..\/lib\/libui.a$/;"	m
LINKED_LIST_ADD_TO_FRONT	mongoose.c	121;"	d	file:
LINKED_LIST_ADD_TO_TAIL	mongoose.c	123;"	d	file:
LINKED_LIST_DECLARE_AND_INIT	mongoose.c	116;"	d	file:
LINKED_LIST_ENTRY	mongoose.c	117;"	d	file:
LINKED_LIST_FOREACH	mongoose.c	119;"	d	file:
LINKED_LIST_INIT	mongoose.c	115;"	d	file:
LINKED_LIST_IS_EMPTY	mongoose.c	118;"	d	file:
LINKED_LIST_REMOVE	mongoose.c	125;"	d	file:
LISTENING_PORT	mongoose.c	/^  INDEX_FILES, LISTENING_PORT, DAV_AUTH_FILE, RUN_AS_USER,$/;"	e	enum:__anon1	file:
LUA_SCRIPT_PATTERN	mongoose.c	132;"	d	file:
MAX_CGI_ENVIR_VARS	mongoose.c	134;"	d	file:
MAX_PATH_SIZE	mongoose.c	131;"	d	file:
MAX_REQUEST_SIZE	mongoose.c	129;"	d	file:
MD5Context	mongoose.c	/^typedef struct MD5Context {$/;"	s	file:
MD5Context::bits	mongoose.c	/^  uint32_t bits[2];$/;"	m	struct:MD5Context	file:	access:public
MD5Context::buf	mongoose.c	/^  uint32_t buf[4];$/;"	m	struct:MD5Context	file:	access:public
MD5Context::in	mongoose.c	/^  unsigned char in[64];$/;"	m	struct:MD5Context	file:	access:public
MD5Final	mongoose.c	/^static void MD5Final(unsigned char digest[16], MD5_CTX *ctx) {$/;"	f	file:	signature:(unsigned char digest[16], MD5_CTX *ctx)
MD5Init	mongoose.c	/^static void MD5Init(MD5_CTX *ctx) {$/;"	f	file:	signature:(MD5_CTX *ctx)
MD5STEP	mongoose.c	2300;"	d	file:
MD5Transform	mongoose.c	/^static void MD5Transform(uint32_t buf[4], uint32_t const in[16]) {$/;"	f	file:	signature:(uint32_t buf[4], uint32_t const in[16])
MD5Update	mongoose.c	/^static void MD5Update(MD5_CTX *ctx, unsigned char const *buf, unsigned len) {$/;"	f	file:	signature:(MD5_CTX *ctx, unsigned char const *buf, unsigned len)
MD5_CTX	mongoose.c	/^} MD5_CTX;$/;"	t	typeref:struct:MD5Context	file:
MONGOOSE_HEADER_INCLUDED	mongoose.h	21;"	d
MONGOOSE_VERSION	mongoose.h	23;"	d
NUM_OPTIONS	mongoose.c	/^  SSL_CERTIFICATE, URL_REWRITES, NUM_OPTIONS$/;"	e	enum:__anon1	file:
OBJ	Makefile	/^OBJ = mongoose.o lib_ui.o cJSON.o$/;"	m
O_BINARY	mongoose.c	109;"	d	file:
PASSWORDS_FILE_NAME	mongoose.c	136;"	d	file:
R0	mongoose.c	1231;"	d	file:
R1	mongoose.c	1232;"	d	file:
R2	mongoose.c	1233;"	d	file:
R3	mongoose.c	1234;"	d	file:
R4	mongoose.c	1235;"	d	file:
RM	Makefile	/^RM = rm -f$/;"	m
RUN_AS_USER	mongoose.c	/^  INDEX_FILES, LISTENING_PORT, DAV_AUTH_FILE, RUN_AS_USER,$/;"	e	enum:__anon1	file:
SHA1Final	mongoose.c	/^static void SHA1Final(unsigned char digest[20], SHA1_CTX* context) {$/;"	f	file:	signature:(unsigned char digest[20], SHA1_CTX* context)
SHA1HANDSOFF	mongoose.c	1211;"	d	file:
SHA1Init	mongoose.c	/^static void SHA1Init(SHA1_CTX* context) {$/;"	f	file:	signature:(SHA1_CTX* context)
SHA1Transform	mongoose.c	/^static void SHA1Transform(uint32_t state[5], const unsigned char buffer[64]) {$/;"	f	file:	signature:(uint32_t state[5], const unsigned char buffer[64])
SHA1Update	mongoose.c	/^static void SHA1Update(SHA1_CTX* context, const unsigned char* data,$/;"	f	file:	signature:(SHA1_CTX* context, const unsigned char* data, uint32_t len)
SHA1_CTX	mongoose.c	/^} SHA1_CTX;$/;"	t	typeref:struct:__anon3	file:
SRC	Makefile	/^SRC = mongoose.c lib_ui.c cJSON.c$/;"	m
SSL_CERTIFICATE	mongoose.c	/^  SSL_CERTIFICATE, URL_REWRITES, NUM_OPTIONS$/;"	e	enum:__anon1	file:
STR	mongoose.c	83;"	d	file:
STRX	mongoose.c	82;"	d	file:
S_ISDIR	mongoose.c	70;"	d	file:
UI_LIB_H	lib_ui.h	2;"	d
URL_REWRITES	mongoose.c	/^  SSL_CERTIFICATE, URL_REWRITES, NUM_OPTIONS$/;"	e	enum:__anon1	file:
WIN32_LEAN_AND_MEAN	mongoose.c	22;"	d	file:
_CRT_SECURE_NO_WARNINGS	cJSON.c	25;"	d	file:
_CRT_SECURE_NO_WARNINGS	mongoose.c	21;"	d	file:
_FILE_OFFSET_BITS	mongoose.c	27;"	d	file:
_INTEGRAL_MAX_BITS	mongoose.c	20;"	d	file:
_LARGEFILE_SOURCE	mongoose.c	26;"	d	file:
_MBCS	mongoose.c	19;"	d	file:
_UNICODE	mongoose.c	18;"	d	file:
_XOPEN_SOURCE	mongoose.c	23;"	d	file:
__STDC_FORMAT_MACROS	mongoose.c	24;"	d	file:
__STDC_LIMIT_MACROS	mongoose.c	25;"	d	file:
__anon2::ext_len	mongoose.c	/^  size_t ext_len;$/;"	m	struct:__anon2	file:	access:public
__anon2::extension	mongoose.c	/^  const char *extension;$/;"	m	struct:__anon2	file:	access:public
__anon2::mime_type	mongoose.c	/^  const char *mime_type;$/;"	m	struct:__anon2	file:	access:public
__anon3::buffer	mongoose.c	/^    unsigned char buffer[64];$/;"	m	struct:__anon3	file:	access:public
__anon3::count	mongoose.c	/^    uint32_t count[2];$/;"	m	struct:__anon3	file:	access:public
__anon3::state	mongoose.c	/^    uint32_t state[5];$/;"	m	struct:__anon3	file:	access:public
__cdecl	mongoose.c	108;"	d	file:
__func__	mongoose.c	84;"	d	file:
accept_new_connection	mongoose.c	/^static struct connection *accept_new_connection(struct mg_server *server) {$/;"	f	file:	signature:(struct mg_server *server)
active_connections	mongoose.c	/^  struct linked_list_link active_connections;$/;"	m	struct:mg_server	typeref:struct:mg_server::linked_list_link	file:	access:public
add_to_set	mongoose.c	/^void add_to_set(sock_t sock, fd_set *set, sock_t *max_fd) {$/;"	f	signature:(sock_t sock, fd_set *set, sock_t *max_fd)
addenv	mongoose.c	/^static char *addenv(struct cgi_env_block *block, const char *fmt, ...) {$/;"	f	file:	signature:(struct cgi_env_block *block, const char *fmt, ...)
addenv2	mongoose.c	/^static void addenv2(struct cgi_env_block *blk, const char *name) {$/;"	f	file:	signature:(struct cgi_env_block *blk, const char *name)
authorize	mongoose.c	/^static int authorize(struct connection *conn, FILE *fp) {$/;"	f	file:	signature:(struct connection *conn, FILE *fp)
base64_encode	mongoose.c	/^static void base64_encode(const unsigned char *src, int src_len, char *dst) {$/;"	f	file:	signature:(const unsigned char *src, int src_len, char *dst)
bin2str	mongoose.c	/^static void bin2str(char *to, const unsigned char *p, size_t len) {$/;"	f	file:	signature:(char *to, const unsigned char *p, size_t len)
birth_time	mongoose.c	/^  time_t birth_time;$/;"	m	struct:connection	file:	access:public
bits	mongoose.c	/^  uint32_t bits[2];$/;"	m	struct:MD5Context	file:	access:public
blk	mongoose.c	1229;"	d	file:
blk0	mongoose.c	/^static uint32_t blk0(union char64long16 *block, int i) {$/;"	f	file:	signature:(union char64long16 *block, int i)
bool	lib_ui.c	6;"	d	file:
buf	mongoose.c	/^  char *buf;    \/\/ Buffer that holds the data$/;"	m	struct:iobuf	file:	access:public
buf	mongoose.c	/^  char buf[CGI_ENVIRONMENT_SIZE];       \/\/ Environment buffer$/;"	m	struct:cgi_env_block	file:	access:public
buf	mongoose.c	/^  uint32_t buf[4];$/;"	m	struct:MD5Context	file:	access:public
buffer	mongoose.c	/^    unsigned char buffer[64];$/;"	m	struct:__anon3	file:	access:public
byteReverse	mongoose.c	/^static void byteReverse(unsigned char *buf, unsigned longs) {$/;"	f	file:	signature:(unsigned char *buf, unsigned longs)
c	mongoose.c	/^union char64long16 { unsigned char c[64]; uint32_t l[16]; };$/;"	m	union:char64long16	file:	access:public
cJSON_AddItemReferenceToArray	cJSON.c	/^void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)						{cJSON_AddItemToArray(array,create_reference(item));}$/;"	f	signature:(cJSON *array, cJSON *item)
cJSON_AddItemReferenceToObject	cJSON.c	/^void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)	{cJSON_AddItemToObject(object,string,create_reference(item));}$/;"	f	signature:(cJSON *object,const char *string,cJSON *item)
cJSON_AddItemToArray	cJSON.c	/^void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}$/;"	f	signature:(cJSON *array, cJSON *item)
cJSON_AddItemToObject	cJSON.c	/^void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}$/;"	f	signature:(cJSON *object,const char *string,cJSON *item)
cJSON_CreateArray	cJSON.c	/^cJSON *cJSON_CreateArray(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}$/;"	f	signature:(void)
cJSON_CreateBool	cJSON.c	/^cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}$/;"	f	signature:(int b)
cJSON_CreateDoubleArray	cJSON.c	/^cJSON *cJSON_CreateDoubleArray(const double *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f	signature:(const double *numbers,int count)
cJSON_CreateFalse	cJSON.c	/^cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}$/;"	f	signature:(void)
cJSON_CreateFloatArray	cJSON.c	/^cJSON *cJSON_CreateFloatArray(const float *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f	signature:(const float *numbers,int count)
cJSON_CreateIntArray	cJSON.c	/^cJSON *cJSON_CreateIntArray(const int *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f	signature:(const int *numbers,int count)
cJSON_CreateNull	cJSON.c	/^cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}$/;"	f	signature:(void)
cJSON_CreateNumber	cJSON.c	/^cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}$/;"	f	signature:(double num)
cJSON_CreateObject	cJSON.c	/^cJSON *cJSON_CreateObject(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}$/;"	f	signature:(void)
cJSON_CreateString	cJSON.c	/^cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}$/;"	f	signature:(const char *string)
cJSON_CreateStringArray	cJSON.c	/^cJSON *cJSON_CreateStringArray(const char **strings,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f	signature:(const char **strings,int count)
cJSON_CreateTrue	cJSON.c	/^cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}$/;"	f	signature:(void)
cJSON_Delete	cJSON.c	/^void cJSON_Delete(cJSON *c)$/;"	f	signature:(cJSON *c)
cJSON_DeleteItemFromArray	cJSON.c	/^void   cJSON_DeleteItemFromArray(cJSON *array,int which)			{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}$/;"	f	signature:(cJSON *array,int which)
cJSON_DeleteItemFromObject	cJSON.c	/^void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}$/;"	f	signature:(cJSON *object,const char *string)
cJSON_DetachItemFromArray	cJSON.c	/^cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)			{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;$/;"	f	signature:(cJSON *array,int which)
cJSON_DetachItemFromObject	cJSON.c	/^cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}$/;"	f	signature:(cJSON *object,const char *string)
cJSON_Duplicate	cJSON.c	/^cJSON *cJSON_Duplicate(cJSON *item,int recurse)$/;"	f	signature:(cJSON *item,int recurse)
cJSON_GetArrayItem	cJSON.c	/^cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}$/;"	f	signature:(cJSON *array,int item)
cJSON_GetArraySize	cJSON.c	/^int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}$/;"	f	signature:(cJSON *array)
cJSON_GetErrorPtr	cJSON.c	/^const char *cJSON_GetErrorPtr(void) {return ep;}$/;"	f	signature:(void)
cJSON_GetObjectItem	cJSON.c	/^cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}$/;"	f	signature:(cJSON *object,const char *string)
cJSON_InitHooks	cJSON.c	/^void cJSON_InitHooks(cJSON_Hooks* hooks)$/;"	f	signature:(cJSON_Hooks* hooks)
cJSON_Minify	cJSON.c	/^void cJSON_Minify(char *json)$/;"	f	signature:(char *json)
cJSON_New_Item	cJSON.c	/^static cJSON *cJSON_New_Item(void)$/;"	f	file:	signature:(void)
cJSON_Parse	cJSON.c	/^cJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}$/;"	f	signature:(const char *value)
cJSON_ParseWithOpts	cJSON.c	/^cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)$/;"	f	signature:(const char *value,const char **return_parse_end,int require_null_terminated)
cJSON_Print	cJSON.c	/^char *cJSON_Print(cJSON *item)				{return print_value(item,0,1);}$/;"	f	signature:(cJSON *item)
cJSON_PrintUnformatted	cJSON.c	/^char *cJSON_PrintUnformatted(cJSON *item)	{return print_value(item,0,0);}$/;"	f	signature:(cJSON *item)
cJSON_ReplaceItemInArray	cJSON.c	/^void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;$/;"	f	signature:(cJSON *array,int which,cJSON *newitem)
cJSON_ReplaceItemInObject	cJSON.c	/^void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}$/;"	f	signature:(cJSON *object,const char *string,cJSON *newitem)
cJSON_free	cJSON.c	/^static void (*cJSON_free)(void *ptr) = free;$/;"	v	file:
cJSON_malloc	cJSON.c	/^static void *(*cJSON_malloc)(size_t sz) = malloc;$/;"	v	file:
cJSON_strcasecmp	cJSON.c	/^static int cJSON_strcasecmp(const char *s1,const char *s2)$/;"	f	file:	signature:(const char *s1,const char *s2)
cJSON_strdup	cJSON.c	/^static char* cJSON_strdup(const char* str)$/;"	f	file:	signature:(const char* str)
call_uri_handler_if_data_is_buffered	mongoose.c	/^static void call_uri_handler_if_data_is_buffered(struct connection *conn) {$/;"	f	file:	signature:(struct connection *conn)
cgi_env_block	mongoose.c	/^struct cgi_env_block {$/;"	s	file:
cgi_env_block::buf	mongoose.c	/^  char buf[CGI_ENVIRONMENT_SIZE];       \/\/ Environment buffer$/;"	m	struct:cgi_env_block	file:	access:public
cgi_env_block::conn	mongoose.c	/^  struct mg_connection *conn;$/;"	m	struct:cgi_env_block	typeref:struct:cgi_env_block::mg_connection	file:	access:public
cgi_env_block::len	mongoose.c	/^  int len;                              \/\/ Space taken$/;"	m	struct:cgi_env_block	file:	access:public
cgi_env_block::nvars	mongoose.c	/^  int nvars;                            \/\/ Number of variables in envp[]$/;"	m	struct:cgi_env_block	file:	access:public
cgi_env_block::vars	mongoose.c	/^  const char *vars[MAX_CGI_ENVIR_VARS]; \/\/ char *envp[]$/;"	m	struct:cgi_env_block	file:	access:public
cgi_sock	mongoose.c	/^  sock_t cgi_sock;          \/\/ CGI socket$/;"	m	union:endpoint	file:	access:public
char64long16	mongoose.c	/^union char64long16 { unsigned char c[64]; uint32_t l[16]; };$/;"	u	file:
char64long16::c	mongoose.c	/^union char64long16 { unsigned char c[64]; uint32_t l[16]; };$/;"	m	union:char64long16	file:	access:public
char64long16::l	mongoose.c	/^union char64long16 { unsigned char c[64]; uint32_t l[16]; };$/;"	m	union:char64long16	file:	access:public
check_acl	mongoose.c	/^static int check_acl(const char *acl, uint32_t remote_ip) {$/;"	f	file:	signature:(const char *acl, uint32_t remote_ip)
check_password	mongoose.c	/^static int check_password(const char *method, const char *ha1, const char *uri,$/;"	f	file:	signature:(const char *method, const char *ha1, const char *uri, const char *nonce, const char *nc, const char *cnonce, const char *qop, const char *response)
cl	mongoose.c	/^  int64_t cl;             \/\/ Reply content length, for Range support$/;"	m	struct:connection	file:	access:public
client_sock	mongoose.c	/^  sock_t client_sock;             \/\/ Connected client$/;"	m	struct:connection	file:	access:public
close_conn	mongoose.c	/^static void close_conn(struct connection *conn) {$/;"	f	file:	signature:(struct connection *conn)
close_local_endpoint	mongoose.c	/^static void close_local_endpoint(struct connection *conn) {$/;"	f	file:	signature:(struct connection *conn)
close_local_endpoint	mongoose.c	/^static void close_local_endpoint(struct connection *conn);$/;"	p	file:	signature:(struct connection *conn)
closedir	mongoose.c	/^static int closedir(DIR *dir) {$/;"	f	file:	signature:(DIR *dir)
closesocket	mongoose.c	97;"	d	file:
compare_dir_entries	mongoose.c	/^static int __cdecl compare_dir_entries(const void *p1, const void *p2) {$/;"	f	file:	signature:(const void *p1, const void *p2)
config_options	mongoose.c	/^  char *config_options[NUM_OPTIONS];$/;"	m	struct:mg_server	file:	access:public
conn	mongoose.c	/^  struct connection *conn;$/;"	m	struct:dir_entry	typeref:struct:dir_entry::connection	file:	access:public
conn	mongoose.c	/^  struct mg_connection *conn;$/;"	m	struct:cgi_env_block	typeref:struct:cgi_env_block::mg_connection	file:	access:public
connection	mongoose.c	/^struct connection {$/;"	s	file:
connection::birth_time	mongoose.c	/^  time_t birth_time;$/;"	m	struct:connection	file:	access:public
connection::cl	mongoose.c	/^  int64_t cl;             \/\/ Reply content length, for Range support$/;"	m	struct:connection	file:	access:public
connection::client_sock	mongoose.c	/^  sock_t client_sock;             \/\/ Connected client$/;"	m	struct:connection	file:	access:public
connection::endpoint	mongoose.c	/^  union endpoint endpoint;$/;"	m	struct:connection	typeref:union:connection::endpoint	file:	access:public
connection::endpoint_type	mongoose.c	/^  enum endpoint_type endpoint_type;$/;"	m	struct:connection	typeref:enum:connection::endpoint_type	file:	access:public
connection::expire_time	mongoose.c	/^  time_t expire_time;$/;"	m	struct:connection	file:	access:public
connection::flags	mongoose.c	/^  int flags;        \/\/ CONN_* flags: CONN_CLOSE, CONN_SPOOL_DONE, etc$/;"	m	struct:connection	file:	access:public
connection::link	mongoose.c	/^  struct linked_list_link link;   \/\/ Linkage to server->active_connections$/;"	m	struct:connection	typeref:struct:connection::linked_list_link	file:	access:public
connection::local_iobuf	mongoose.c	/^  struct iobuf local_iobuf;$/;"	m	struct:connection	typeref:struct:connection::iobuf	file:	access:public
connection::mg_conn	mongoose.c	/^  struct mg_connection mg_conn;   \/\/ XXX: Must be first$/;"	m	struct:connection	typeref:struct:connection::mg_connection	file:	access:public
connection::mutex	mongoose.c	/^  mutex_t mutex;    \/\/ Guards concurrent mg_write() calls$/;"	m	struct:connection	file:	access:public
connection::num_bytes_sent	mongoose.c	/^  int64_t num_bytes_sent; \/\/ Total number of bytes sent$/;"	m	struct:connection	file:	access:public
connection::path_info	mongoose.c	/^  char *path_info;$/;"	m	struct:connection	file:	access:public
connection::remote_iobuf	mongoose.c	/^  struct iobuf remote_iobuf;$/;"	m	struct:connection	typeref:struct:connection::iobuf	file:	access:public
connection::request	mongoose.c	/^  char *request;$/;"	m	struct:connection	file:	access:public
connection::request_len	mongoose.c	/^  int request_len;  \/\/ Request length, including last \\r\\n after last header$/;"	m	struct:connection	file:	access:public
connection::server	mongoose.c	/^  struct mg_server *server;$/;"	m	struct:connection	typeref:struct:connection::mg_server	file:	access:public
connection_flags	mongoose.c	/^enum connection_flags { CONN_CLOSE = 1, CONN_SPOOL_DONE = 2, CONN_SSL = 4 };$/;"	g	file:
connection_param	mongoose.h	/^  void *connection_param;     \/\/ Placeholder for connection-specific data$/;"	m	struct:mg_connection	access:public
construct_etag	mongoose.c	/^static void construct_etag(char *buf, size_t buf_len, const file_stat_t *st) {$/;"	f	file:	signature:(char *buf, size_t buf_len, const file_stat_t *st)
content	mongoose.h	/^  char *content;              \/\/ POST (or websocket message) data, or NULL$/;"	m	struct:mg_connection	access:public
content_len	mongoose.h	/^  int content_len;            \/\/ content length$/;"	m	struct:mg_connection	access:public
convert_uri_to_file_name	mongoose.c	/^static int convert_uri_to_file_name(struct connection *conn, char *buf,$/;"	f	file:	signature:(struct connection *conn, char *buf, size_t buf_len, file_stat_t *st)
count	mongoose.c	/^    uint32_t count[2];$/;"	m	struct:__anon3	file:	access:public
create_reference	cJSON.c	/^static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}$/;"	f	file:	signature:(cJSON *item)
ctl	mongoose.c	/^  sock_t ctl[2];  \/\/ Control socketpair. Used to wake up from select() call$/;"	m	struct:mg_server	file:	access:public
d_name	mongoose.c	/^  char d_name[MAX_PATH_SIZE];$/;"	m	struct:dirent	file:	access:public
deliver_websocket_frame	mongoose.c	/^static int deliver_websocket_frame(struct connection *conn) {$/;"	f	file:	signature:(struct connection *conn)
dir_entry	mongoose.c	/^struct dir_entry {$/;"	s	file:
dir_entry::conn	mongoose.c	/^  struct connection *conn;$/;"	m	struct:dir_entry	typeref:struct:dir_entry::connection	file:	access:public
dir_entry::file_name	mongoose.c	/^  char *file_name;$/;"	m	struct:dir_entry	file:	access:public
dir_entry::st	mongoose.c	/^  file_stat_t st;$/;"	m	struct:dir_entry	file:	access:public
dirent	mongoose.c	/^struct dirent {$/;"	s	file:
dirent::d_name	mongoose.c	/^  char d_name[MAX_PATH_SIZE];$/;"	m	struct:dirent	file:	access:public
endpoint	mongoose.c	/^  union endpoint endpoint;$/;"	m	struct:connection	typeref:union:connection::endpoint	file:	access:public
endpoint	mongoose.c	/^union endpoint {$/;"	u	file:
endpoint::cgi_sock	mongoose.c	/^  sock_t cgi_sock;          \/\/ CGI socket$/;"	m	union:endpoint	file:	access:public
endpoint::fd	mongoose.c	/^  int fd;                   \/\/ Opened regular local file$/;"	m	union:endpoint	file:	access:public
endpoint::ssl	mongoose.c	/^  void *ssl;                \/\/ SSL descriptor$/;"	m	union:endpoint	file:	access:public
endpoint::uh	mongoose.c	/^  struct uri_handler *uh;   \/\/ URI handler user function$/;"	m	union:endpoint	typeref:struct:endpoint::uri_handler	file:	access:public
endpoint_type	mongoose.c	/^  enum endpoint_type endpoint_type;$/;"	m	struct:connection	typeref:enum:connection::endpoint_type	file:	access:public
endpoint_type	mongoose.c	/^enum endpoint_type { EP_NONE, EP_FILE, EP_CGI, EP_USER, EP_PUT };$/;"	g	file:
ep	cJSON.c	/^static const char *ep;$/;"	v	file:
evn_setup	lib_ui.c	/^static int evn_setup(struct mg_connection *conn)$/;"	f	file:	signature:(struct mg_connection *conn)
expire_time	mongoose.c	/^  time_t expire_time;$/;"	m	struct:connection	file:	access:public
ext_len	mongoose.c	/^  size_t ext_len;$/;"	m	struct:__anon2	file:	access:public
extension	mongoose.c	/^  const char *extension;$/;"	m	struct:__anon2	file:	access:public
false	lib_ui.c	8;"	d	file:
fd	mongoose.c	/^  int fd;                   \/\/ Opened regular local file$/;"	m	union:endpoint	file:	access:public
file_name	mongoose.c	/^  char *file_name;$/;"	m	struct:dir_entry	file:	access:public
file_stat_t	mongoose.c	/^typedef struct _stati64 file_stat_t;$/;"	t	typeref:struct:_stati64	file:
file_stat_t	mongoose.c	/^typedef struct stat file_stat_t;$/;"	t	typeref:struct:stat	file:
find_index_file	mongoose.c	/^static int find_index_file(struct connection *conn, char *path,$/;"	f	file:	signature:(struct connection *conn, char *path, size_t path_len, file_stat_t *stp)
find_uri_handler	mongoose.c	/^static struct uri_handler *find_uri_handler(struct mg_server *server,$/;"	f	file:	signature:(struct mg_server *server, const char *uri)
firstByteMark	cJSON.c	/^static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };$/;"	v	file:
flags	mongoose.c	/^  int flags;        \/\/ CONN_* flags: CONN_CLOSE, CONN_SPOOL_DONE, etc$/;"	m	struct:connection	file:	access:public
flockfile	mongoose.c	76;"	d	file:
forward_post_data	mongoose.c	/^static void forward_post_data(struct connection *conn) {$/;"	f	file:	signature:(struct connection *conn)
forward_put_data	mongoose.c	/^static void forward_put_data(struct connection *conn) {$/;"	f	file:	signature:(struct connection *conn)
funlockfile	mongoose.c	77;"	d	file:
get_mime_type	mongoose.c	/^static void get_mime_type(const struct mg_server *server, const char *path,$/;"	f	file:	signature:(const struct mg_server *server, const char *path, struct vec *vec)
get_month_index	mongoose.c	/^static int get_month_index(const char *s) {$/;"	f	file:	signature:(const char *s)
get_option_index	mongoose.c	/^static int get_option_index(const char *name) {$/;"	f	file:	signature:(const char *name)
get_request_len	mongoose.c	/^static int get_request_len(const char *s, int buf_len) {$/;"	f	file:	signature:(const char *s, int buf_len)
get_var	mongoose.c	/^static int get_var(const char *data, size_t data_len, const char *name,$/;"	f	file:	signature:(const char *data, size_t data_len, const char *name, char *dst, size_t dst_len)
gmt_time_string	mongoose.c	/^static void gmt_time_string(char *buf, size_t buf_len, time_t *t) {$/;"	f	file:	signature:(char *buf, size_t buf_len, time_t *t)
handle	mongoose.c	/^  HANDLE   handle;$/;"	m	struct:DIR	file:	access:public
handle_delete	mongoose.c	/^static void handle_delete(struct connection *conn, const char *path) {$/;"	f	file:	signature:(struct connection *conn, const char *path)
handle_lua_request	mongoose.c	/^static void handle_lua_request(struct connection *conn, const char *path) {$/;"	f	file:	signature:(struct connection *conn, const char *path)
handle_mkcol	mongoose.c	/^static void handle_mkcol(struct connection *conn, const char *path) {$/;"	f	file:	signature:(struct connection *conn, const char *path)
handle_propfind	mongoose.c	/^static void handle_propfind(struct connection *conn, const char *path,$/;"	f	file:	signature:(struct connection *conn, const char *path, file_stat_t *stp)
handle_put	mongoose.c	/^static void handle_put(struct connection *conn, const char *path) {$/;"	f	file:	signature:(struct connection *conn, const char *path)
handler	mongoose.c	/^  mg_handler_t handler;$/;"	m	struct:uri_handler	file:	access:public
http_headers	mongoose.h	/^  } http_headers[30];$/;"	m	struct:mg_connection	typeref:struct:mg_connection::mg_header	access:public
http_version	mongoose.h	/^  const char *http_version;   \/\/ E.g. "1.0", "1.1"$/;"	m	struct:mg_connection	access:public
in	mongoose.c	/^  unsigned char in[64];$/;"	m	struct:MD5Context	file:	access:public
info	mongoose.c	/^  WIN32_FIND_DATAW info;$/;"	m	struct:DIR	file:	access:public
int64_t	mongoose.c	/^typedef __int64   int64_t;$/;"	t	file:
iobuf	mongoose.c	/^struct iobuf {$/;"	s	file:
iobuf::buf	mongoose.c	/^  char *buf;    \/\/ Buffer that holds the data$/;"	m	struct:iobuf	file:	access:public
iobuf::len	mongoose.c	/^  int len;      \/\/ Number of bytes currently in a buffer$/;"	m	struct:iobuf	file:	access:public
iobuf::size	mongoose.c	/^  int size;     \/\/ Buffer size$/;"	m	struct:iobuf	file:	access:public
is_authorized	mongoose.c	/^static int is_authorized(struct connection *conn, const char *path) {$/;"	f	file:	signature:(struct connection *conn, const char *path)
is_authorized_for_dav	mongoose.c	/^static int is_authorized_for_dav(struct connection *conn) {$/;"	f	file:	signature:(struct connection *conn)
is_big_endian	mongoose.c	/^static int is_big_endian(void) {$/;"	f	file:	signature:(void)
is_dangerous_dav_request	mongoose.c	/^static int is_dangerous_dav_request(const struct connection *conn) {$/;"	f	file:	signature:(const struct connection *conn)
is_error	mongoose.c	/^static int is_error(int n) {$/;"	f	file:	signature:(int n)
is_not_modified	mongoose.c	/^static int is_not_modified(const struct connection *conn,$/;"	f	file:	signature:(const struct connection *conn, const file_stat_t *stp)
is_valid_http_method	mongoose.c	/^static int is_valid_http_method(const char *method) {$/;"	f	file:	signature:(const char *method)
is_valid_uri	mongoose.c	/^static int is_valid_uri(const char *uri) {$/;"	f	file:	signature:(const char *uri)
is_websocket	mongoose.h	/^  int is_websocket;           \/\/ Connection is a websocket connection$/;"	m	struct:mg_connection	access:public
isbyte	mongoose.c	/^static int isbyte(int n) {$/;"	f	file:	signature:(int n)
l	mongoose.c	/^union char64long16 { unsigned char c[64]; uint32_t l[16]; };$/;"	m	union:char64long16	file:	access:public
len	mongoose.c	/^  int len;                              \/\/ Space taken$/;"	m	struct:cgi_env_block	file:	access:public
len	mongoose.c	/^  int len;      \/\/ Number of bytes currently in a buffer$/;"	m	struct:iobuf	file:	access:public
len	mongoose.c	/^  int len;$/;"	m	struct:vec	file:	access:public
link	mongoose.c	/^  struct linked_list_link link;   \/\/ Linkage to server->active_connections$/;"	m	struct:connection	typeref:struct:connection::linked_list_link	file:	access:public
link	mongoose.c	/^  struct linked_list_link link;$/;"	m	struct:uri_handler	typeref:struct:uri_handler::linked_list_link	file:	access:public
linked_list_link	mongoose.c	/^struct linked_list_link { struct linked_list_link *prev, *next; };$/;"	s	file:
linked_list_link::next	mongoose.c	/^struct linked_list_link { struct linked_list_link *prev, *next; };$/;"	m	struct:linked_list_link	typeref:struct:linked_list_link::	file:	access:public
linked_list_link::prev	mongoose.c	/^struct linked_list_link { struct linked_list_link *prev, *next; };$/;"	m	struct:linked_list_link	typeref:struct:linked_list_link::linked_list_link	file:	access:public
listening_sock	mongoose.c	/^  sock_t listening_sock;$/;"	m	struct:mg_server	file:	access:public
local_iobuf	mongoose.c	/^  struct iobuf local_iobuf;$/;"	m	struct:connection	typeref:struct:connection::iobuf	file:	access:public
log_access	mongoose.c	/^static void log_access(const struct connection *conn, const char *path) {$/;"	f	file:	signature:(const struct connection *conn, const char *path)
log_header	mongoose.c	/^static void log_header(const struct mg_connection *conn, const char *header,$/;"	f	file:	signature:(const struct mg_connection *conn, const char *header, FILE *fp)
lowercase	mongoose.c	/^static int lowercase(const char *s) {$/;"	f	file:	signature:(const char *s)
lsa	mongoose.c	/^  union socket_address lsa;   \/\/ Listening socket address$/;"	m	struct:mg_server	typeref:union:mg_server::socket_address	file:	access:public
lseek	mongoose.c	73;"	d	file:
lua_error_handler	mongoose.c	/^static int lua_error_handler(lua_State *L) {$/;"	f	file:	signature:(lua_State *L)
lua_write	mongoose.c	/^static int lua_write(lua_State *L) {$/;"	f	file:	signature:(lua_State *L)
match_prefix	mongoose.c	/^static int match_prefix(const char *pattern, int pattern_len, const char *str) {$/;"	f	file:	signature:(const char *pattern, int pattern_len, const char *str)
mg_add_uri_handler	mongoose.c	/^void mg_add_uri_handler(struct mg_server *server, const char *uri,$/;"	f	signature:(struct mg_server *server, const char *uri, mg_handler_t handler)
mg_add_uri_handler	mongoose.h	/^void mg_add_uri_handler(struct mg_server *, const char *uri, mg_handler_t);$/;"	p	signature:(struct mg_server *, const char *uri, mg_handler_t)
mg_conn	mongoose.c	/^  struct mg_connection mg_conn;   \/\/ XXX: Must be first$/;"	m	struct:connection	typeref:struct:connection::mg_connection	file:	access:public
mg_connection	mongoose.h	/^struct mg_connection {$/;"	s
mg_connection::connection_param	mongoose.h	/^  void *connection_param;     \/\/ Placeholder for connection-specific data$/;"	m	struct:mg_connection	access:public
mg_connection::content	mongoose.h	/^  char *content;              \/\/ POST (or websocket message) data, or NULL$/;"	m	struct:mg_connection	access:public
mg_connection::content_len	mongoose.h	/^  int content_len;            \/\/ content length$/;"	m	struct:mg_connection	access:public
mg_connection::http_headers	mongoose.h	/^  } http_headers[30];$/;"	m	struct:mg_connection	typeref:struct:mg_connection::mg_header	access:public
mg_connection::http_version	mongoose.h	/^  const char *http_version;   \/\/ E.g. "1.0", "1.1"$/;"	m	struct:mg_connection	access:public
mg_connection::is_websocket	mongoose.h	/^  int is_websocket;           \/\/ Connection is a websocket connection$/;"	m	struct:mg_connection	access:public
mg_connection::mg_header	mongoose.h	/^  struct mg_header {$/;"	s	struct:mg_connection	access:public
mg_connection::mg_header::name	mongoose.h	/^    const char *name;         \/\/ HTTP header name$/;"	m	struct:mg_connection::mg_header	access:public
mg_connection::mg_header::value	mongoose.h	/^    const char *value;        \/\/ HTTP header value$/;"	m	struct:mg_connection::mg_header	access:public
mg_connection::num_headers	mongoose.h	/^  int num_headers;            \/\/ Number of HTTP headers$/;"	m	struct:mg_connection	access:public
mg_connection::query_string	mongoose.h	/^  const char *query_string;   \/\/ URL part after '?', not including '?', or NULL$/;"	m	struct:mg_connection	access:public
mg_connection::remote_ip	mongoose.h	/^  char remote_ip[48];         \/\/ Max IPv6 string length is 45 characters$/;"	m	struct:mg_connection	access:public
mg_connection::remote_port	mongoose.h	/^  int remote_port;            \/\/ Client's port$/;"	m	struct:mg_connection	access:public
mg_connection::request_method	mongoose.h	/^  const char *request_method; \/\/ "GET", "POST", etc$/;"	m	struct:mg_connection	access:public
mg_connection::server_param	mongoose.h	/^  void *server_param;         \/\/ Parameter passed to mg_add_uri_handler()$/;"	m	struct:mg_connection	access:public
mg_connection::status_code	mongoose.h	/^  int status_code;            \/\/ HTTP status code for HTTP error handler$/;"	m	struct:mg_connection	access:public
mg_connection::uri	mongoose.h	/^  const char *uri;            \/\/ URL-decoded URI$/;"	m	struct:mg_connection	access:public
mg_connection::wsbits	mongoose.h	/^  unsigned char wsbits;       \/\/ First byte of the websocket frame$/;"	m	struct:mg_connection	access:public
mg_create_server	mongoose.c	/^struct mg_server *mg_create_server(void *server_data) {$/;"	f	signature:(void *server_data)
mg_create_server	mongoose.h	/^struct mg_server *mg_create_server(void *server_param);$/;"	p	signature:(void *server_param)
mg_destroy_server	mongoose.c	/^void mg_destroy_server(struct mg_server **server) {$/;"	f	signature:(struct mg_server **server)
mg_destroy_server	mongoose.h	/^void mg_destroy_server(struct mg_server **);$/;"	p	signature:(struct mg_server **)
mg_get_header	mongoose.c	/^const char *mg_get_header(const struct mg_connection *ri, const char *s) {$/;"	f	signature:(const struct mg_connection *ri, const char *s)
mg_get_header	mongoose.h	/^const char *mg_get_header(const struct mg_connection *, const char *name);$/;"	p	signature:(const struct mg_connection *, const char *name)
mg_get_mime_type	mongoose.c	/^const char *mg_get_mime_type(const char *path) {$/;"	f	signature:(const char *path)
mg_get_mime_type	mongoose.h	/^const char *mg_get_mime_type(const char *file_name);$/;"	p	signature:(const char *file_name)
mg_get_option	mongoose.c	/^const char *mg_get_option(const struct mg_server *server, const char *name) {$/;"	f	signature:(const struct mg_server *server, const char *name)
mg_get_option	mongoose.h	/^const char *mg_get_option(const struct mg_server *server, const char *name);$/;"	p	signature:(const struct mg_server *server, const char *name)
mg_get_valid_option_names	mongoose.c	/^const char **mg_get_valid_option_names(void) {$/;"	f	signature:(void)
mg_get_valid_option_names	mongoose.h	/^const char **mg_get_valid_option_names(void);$/;"	p	signature:(void)
mg_get_var	mongoose.c	/^int mg_get_var(const struct mg_connection *conn, const char *name,$/;"	f	signature:(const struct mg_connection *conn, const char *name, char *dst, size_t dst_len)
mg_get_var	mongoose.h	/^int mg_get_var(const struct mg_connection *conn, const char *var_name,$/;"	p	signature:(const struct mg_connection *conn, const char *var_name, char *buf, size_t buf_len)
mg_handler_t	mongoose.h	/^typedef int (*mg_handler_t)(struct mg_connection *);$/;"	t
mg_header	mongoose.h	/^  struct mg_header {$/;"	s	struct:mg_connection	access:public
mg_iterate_over_connections	mongoose.c	/^int mg_iterate_over_connections(struct mg_server *server,$/;"	f	signature:(struct mg_server *server, void (*func)(struct mg_connection *, void *), void *param)
mg_iterate_over_connections	mongoose.h	/^int mg_iterate_over_connections(struct mg_server *,$/;"	p	signature:(struct mg_server *, void (*func)(struct mg_connection *, void *), void *param)
mg_md5	mongoose.c	/^char *mg_md5(char buf[33], ...) {$/;"	f	signature:(char buf[33], ...)
mg_md5	mongoose.h	/^char *mg_md5(char buf[33], ...);$/;"	p	signature:(char buf[33], ...)
mg_parse_header	mongoose.c	/^int mg_parse_header(const char *str, const char *var_name, char *buf,$/;"	f	signature:(const char *str, const char *var_name, char *buf, size_t buf_size)
mg_parse_header	mongoose.h	/^int mg_parse_header(const char *hdr, const char *var_name, char *buf, size_t);$/;"	p	signature:(const char *hdr, const char *var_name, char *buf, size_t)
mg_poll_server	mongoose.c	/^void mg_poll_server(struct mg_server *server, int milliseconds) {$/;"	f	signature:(struct mg_server *server, int milliseconds)
mg_poll_server	mongoose.h	/^void mg_poll_server(struct mg_server *, int milliseconds);$/;"	p	signature:(struct mg_server *, int milliseconds)
mg_printf	mongoose.c	/^static void mg_printf(struct connection *conn, const char *fmt, ...) {$/;"	f	file:	signature:(struct connection *conn, const char *fmt, ...)
mg_server	mongoose.c	/^struct mg_server {$/;"	s	file:
mg_server::active_connections	mongoose.c	/^  struct linked_list_link active_connections;$/;"	m	struct:mg_server	typeref:struct:mg_server::linked_list_link	file:	access:public
mg_server::config_options	mongoose.c	/^  char *config_options[NUM_OPTIONS];$/;"	m	struct:mg_server	file:	access:public
mg_server::ctl	mongoose.c	/^  sock_t ctl[2];  \/\/ Control socketpair. Used to wake up from select() call$/;"	m	struct:mg_server	file:	access:public
mg_server::listening_sock	mongoose.c	/^  sock_t listening_sock;$/;"	m	struct:mg_server	file:	access:public
mg_server::lsa	mongoose.c	/^  union socket_address lsa;   \/\/ Listening socket address$/;"	m	struct:mg_server	typeref:union:mg_server::socket_address	file:	access:public
mg_server::server_data	mongoose.c	/^  void *server_data;$/;"	m	struct:mg_server	file:	access:public
mg_server::uri_handlers	mongoose.c	/^  struct linked_list_link uri_handlers;$/;"	m	struct:mg_server	typeref:struct:mg_server::linked_list_link	file:	access:public
mg_set_http_error_handler	mongoose.h	/^void mg_set_http_error_handler(struct mg_server *, mg_handler_t);$/;"	p	signature:(struct mg_server *, mg_handler_t)
mg_set_option	mongoose.c	/^const char *mg_set_option(struct mg_server *server, const char *name,$/;"	f	signature:(struct mg_server *server, const char *name, const char *value)
mg_set_option	mongoose.h	/^const char *mg_set_option(struct mg_server *, const char *opt, const char *val);$/;"	p	signature:(struct mg_server *, const char *opt, const char *val)
mg_snprintf	mongoose.c	/^static int mg_snprintf(char *buf, size_t buflen, const char *fmt, ...) {$/;"	f	file:	signature:(char *buf, size_t buflen, const char *fmt, ...)
mg_socketpair	mongoose.c	/^static int mg_socketpair(sock_t sp[2]) {$/;"	f	file:	signature:(sock_t sp[2])
mg_start_thread	mongoose.c	/^void *mg_start_thread(void *(*f)(void *), void *p) {$/;"	f	signature:(void *(*f)(void *), void *p)
mg_start_thread	mongoose.h	/^void *mg_start_thread(void *(*func)(void *), void *param);$/;"	p	signature:(void *(*func)(void *), void *param)
mg_strcasecmp	mongoose.c	/^static int mg_strcasecmp(const char *s1, const char *s2) {$/;"	f	file:	signature:(const char *s1, const char *s2)
mg_strdup	mongoose.c	/^static char *mg_strdup(const char *str) {$/;"	f	file:	signature:(const char *str)
mg_strlcpy	mongoose.c	/^static void mg_strlcpy(register char *dst, register const char *src, size_t n) {$/;"	f	file:	signature:(register char *dst, register const char *src, size_t n)
mg_strncasecmp	mongoose.c	/^static int mg_strncasecmp(const char *s1, const char *s2, size_t len) {$/;"	f	file:	signature:(const char *s1, const char *s2, size_t len)
mg_url_decode	mongoose.c	/^int mg_url_decode(const char *src, int src_len, char *dst,$/;"	f	signature:(const char *src, int src_len, char *dst, int dst_len, int is_form_url_encoded)
mg_url_encode	mongoose.c	/^static void mg_url_encode(const char *src, char *dst, size_t dst_len) {$/;"	f	file:	signature:(const char *src, char *dst, size_t dst_len)
mg_vsnprintf	mongoose.c	/^static int mg_vsnprintf(char *buf, size_t buflen, const char *fmt, va_list ap) {$/;"	f	file:	signature:(char *buf, size_t buflen, const char *fmt, va_list ap)
mg_websocket_write	mongoose.c	/^int mg_websocket_write(struct mg_connection* conn, int opcode,$/;"	f	signature:(struct mg_connection* conn, int opcode, const char *data, size_t data_len)
mg_websocket_write	mongoose.h	/^int mg_websocket_write(struct mg_connection *, int opcode,$/;"	p	signature:(struct mg_connection *, int opcode, const char *data, size_t data_len)
mg_write	mongoose.c	/^int mg_write(struct mg_connection *c, const void *buf, int len) {$/;"	f	signature:(struct mg_connection *c, const void *buf, int len)
mg_write	mongoose.h	/^int mg_write(struct mg_connection *, const void *buf, int len);$/;"	p	signature:(struct mg_connection *, const void *buf, int len)
mg_write_chunked	mongoose.c	/^static int mg_write_chunked(struct connection *conn, const char *buf, int len) {$/;"	f	file:	signature:(struct connection *conn, const char *buf, int len)
mime_type	mongoose.c	/^  const char *mime_type;$/;"	m	struct:__anon2	file:	access:public
mission_setup	lib_ui.c	/^static int mission_setup(struct mg_connection *conn)$/;"	f	file:	signature:(struct mg_connection *conn)
mkdir	mongoose.c	74;"	d	file:
must_hide_file	mongoose.c	/^static int must_hide_file(struct connection *conn, const char *path) {$/;"	f	file:	signature:(struct connection *conn, const char *path)
mutex	mongoose.c	/^  mutex_t mutex;    \/\/ Guards concurrent mg_write() calls$/;"	m	struct:connection	file:	access:public
mutex_destroy	mongoose.c	102;"	d	file:
mutex_destroy	mongoose.c	67;"	d	file:
mutex_init	mongoose.c	101;"	d	file:
mutex_init	mongoose.c	66;"	d	file:
mutex_lock	mongoose.c	103;"	d	file:
mutex_lock	mongoose.c	68;"	d	file:
mutex_t	mongoose.c	/^typedef CRITICAL_SECTION mutex_t;$/;"	t	file:
mutex_t	mongoose.c	/^typedef pthread_mutex_t mutex_t;$/;"	t	file:
mutex_unlock	mongoose.c	104;"	d	file:
mutex_unlock	mongoose.c	69;"	d	file:
name	mongoose.h	/^    const char *name;         \/\/ HTTP header name$/;"	m	struct:mg_connection::mg_header	access:public
next	mongoose.c	/^struct linked_list_link { struct linked_list_link *prev, *next; };$/;"	m	struct:linked_list_link	typeref:struct:linked_list_link::	file:	access:public
next_option	mongoose.c	/^static const char *next_option(const char *list, struct vec *val,$/;"	f	file:	signature:(const char *list, struct vec *val, struct vec *eq_val)
num_bytes_sent	mongoose.c	/^  int64_t num_bytes_sent; \/\/ Total number of bytes sent$/;"	m	struct:connection	file:	access:public
num_headers	mongoose.h	/^  int num_headers;            \/\/ Number of HTTP headers$/;"	m	struct:mg_connection	access:public
num_leap_years	mongoose.c	/^static int num_leap_years(int year) {$/;"	f	file:	signature:(int year)
nvars	mongoose.c	/^  int nvars;                            \/\/ Number of variables in envp[]$/;"	m	struct:cgi_env_block	file:	access:public
open_auth_file	mongoose.c	/^static FILE *open_auth_file(struct connection *conn, const char *path) {$/;"	f	file:	signature:(struct connection *conn, const char *path)
open_cgi_endpoint	mongoose.c	/^static void open_cgi_endpoint(struct connection *conn, const char *prog) {$/;"	f	file:	signature:(struct connection *conn, const char *prog)
open_file_endpoint	mongoose.c	/^static void open_file_endpoint(struct connection *conn, const char *path,$/;"	f	file:	signature:(struct connection *conn, const char *path, file_stat_t *st)
open_listening_socket	mongoose.c	/^static sock_t open_listening_socket(union socket_address *sa) {$/;"	f	file:	signature:(union socket_address *sa)
open_local_endpoint	mongoose.c	/^static void open_local_endpoint(struct connection *conn) {$/;"	f	file:	signature:(struct connection *conn)
opendir	mongoose.c	/^static DIR *opendir(const char *name) {$/;"	f	file:	signature:(const char *name)
parse_array	cJSON.c	/^static const char *parse_array(cJSON *item,const char *value)$/;"	f	file:	signature:(cJSON *item,const char *value)
parse_array	cJSON.c	/^static const char *parse_array(cJSON *item,const char *value);$/;"	p	file:	signature:(cJSON *item,const char *value)
parse_data	lib_ui.c	/^static int parse_data(const char *data)$/;"	f	file:	signature:(const char *data)
parse_date_string	mongoose.c	/^static time_t parse_date_string(const char *datetime) {$/;"	f	file:	signature:(const char *datetime)
parse_hex4	cJSON.c	/^static unsigned parse_hex4(const char *str)$/;"	f	file:	signature:(const char *str)
parse_http_headers	mongoose.c	/^static void parse_http_headers(char **buf, struct mg_connection *ri) {$/;"	f	file:	signature:(char **buf, struct mg_connection *ri)
parse_http_message	mongoose.c	/^static int parse_http_message(char *buf, int len, struct mg_connection *ri) {$/;"	f	file:	signature:(char *buf, int len, struct mg_connection *ri)
parse_net	mongoose.c	/^static int parse_net(const char *spec, uint32_t *net, uint32_t *mask) {$/;"	f	file:	signature:(const char *spec, uint32_t *net, uint32_t *mask)
parse_number	cJSON.c	/^static const char *parse_number(cJSON *item,const char *num)$/;"	f	file:	signature:(cJSON *item,const char *num)
parse_object	cJSON.c	/^static const char *parse_object(cJSON *item,const char *value)$/;"	f	file:	signature:(cJSON *item,const char *value)
parse_object	cJSON.c	/^static const char *parse_object(cJSON *item,const char *value);$/;"	p	file:	signature:(cJSON *item,const char *value)
parse_port_string	mongoose.c	/^static int parse_port_string(const char *str, union socket_address *sa) {$/;"	f	file:	signature:(const char *str, union socket_address *sa)
parse_range_header	mongoose.c	/^static int parse_range_header(const char *header, int64_t *a, int64_t *b) {$/;"	f	file:	signature:(const char *header, int64_t *a, int64_t *b)
parse_string	cJSON.c	/^static const char *parse_string(cJSON *item,const char *str)$/;"	f	file:	signature:(cJSON *item,const char *str)
parse_value	cJSON.c	/^static const char *parse_value(cJSON *item,const char *value)$/;"	f	file:	signature:(cJSON *item,const char *value)
parse_value	cJSON.c	/^static const char *parse_value(cJSON *item,const char *value);$/;"	p	file:	signature:(cJSON *item,const char *value)
path_info	mongoose.c	/^  char *path_info;$/;"	m	struct:connection	file:	access:public
pid_t	mongoose.c	/^typedef int pid_t;$/;"	t	file:
prepare_cgi_environment	mongoose.c	/^static void prepare_cgi_environment(struct connection *conn,$/;"	f	file:	signature:(struct connection *conn, const char *prog, struct cgi_env_block *blk)
prepare_lua_environment	mongoose.c	/^static void prepare_lua_environment(struct mg_connection *ri, lua_State *L) {$/;"	f	file:	signature:(struct mg_connection *ri, lua_State *L)
prev	mongoose.c	/^struct linked_list_link { struct linked_list_link *prev, *next; };$/;"	m	struct:linked_list_link	typeref:struct:linked_list_link::linked_list_link	file:	access:public
print_array	cJSON.c	/^static char *print_array(cJSON *item,int depth,int fmt)$/;"	f	file:	signature:(cJSON *item,int depth,int fmt)
print_array	cJSON.c	/^static char *print_array(cJSON *item,int depth,int fmt);$/;"	p	file:	signature:(cJSON *item,int depth,int fmt)
print_dir_entry	mongoose.c	/^static void print_dir_entry(const struct dir_entry *de) {$/;"	f	file:	signature:(const struct dir_entry *de)
print_number	cJSON.c	/^static char *print_number(cJSON *item)$/;"	f	file:	signature:(cJSON *item)
print_object	cJSON.c	/^static char *print_object(cJSON *item,int depth,int fmt)$/;"	f	file:	signature:(cJSON *item,int depth,int fmt)
print_object	cJSON.c	/^static char *print_object(cJSON *item,int depth,int fmt);$/;"	p	file:	signature:(cJSON *item,int depth,int fmt)
print_props	mongoose.c	/^static void print_props(struct connection *conn, const char *uri,$/;"	f	file:	signature:(struct connection *conn, const char *uri, file_stat_t *stp)
print_string	cJSON.c	/^static char *print_string(cJSON *item)	{return print_string_ptr(item->valuestring);}$/;"	f	file:	signature:(cJSON *item)
print_string_ptr	cJSON.c	/^static char *print_string_ptr(const char *str)$/;"	f	file:	signature:(const char *str)
print_value	cJSON.c	/^static char *print_value(cJSON *item,int depth,int fmt)$/;"	f	file:	signature:(cJSON *item,int depth,int fmt)
print_value	cJSON.c	/^static char *print_value(cJSON *item,int depth,int fmt);$/;"	p	file:	signature:(cJSON *item,int depth,int fmt)
process_request	mongoose.c	/^static void process_request(struct connection *conn) {$/;"	f	file:	signature:(struct connection *conn)
ptr	mongoose.c	/^  const char *ptr;$/;"	m	struct:vec	file:	access:public
put_dir	mongoose.c	/^static int put_dir(const char *path) {$/;"	f	file:	signature:(const char *path)
query_string	mongoose.h	/^  const char *query_string;   \/\/ URL part after '?', not including '?', or NULL$/;"	m	struct:mg_connection	access:public
read_from_cgi	mongoose.c	/^static void read_from_cgi(struct connection *conn) {$/;"	f	file:	signature:(struct connection *conn)
read_from_client	mongoose.c	/^static void read_from_client(struct connection *conn) {$/;"	f	file:	signature:(struct connection *conn)
readdir	mongoose.c	/^static struct dirent *readdir(DIR *dir) {$/;"	f	file:	signature:(DIR *dir)
reg_function	mongoose.c	/^static void reg_function(struct lua_State *L, const char *name,$/;"	f	file:	signature:(struct lua_State *L, const char *name, lua_CFunction func, struct mg_connection *conn)
reg_int	mongoose.c	/^static void reg_int(struct lua_State *L, const char *name, int val) {$/;"	f	file:	signature:(struct lua_State *L, const char *name, int val)
reg_string	mongoose.c	/^static void reg_string(struct lua_State *L, const char *name, const char *val) {$/;"	f	file:	signature:(struct lua_State *L, const char *name, const char *val)
remote_iobuf	mongoose.c	/^  struct iobuf remote_iobuf;$/;"	m	struct:connection	typeref:struct:connection::iobuf	file:	access:public
remote_ip	mongoose.h	/^  char remote_ip[48];         \/\/ Max IPv6 string length is 45 characters$/;"	m	struct:mg_connection	access:public
remote_port	mongoose.h	/^  int remote_port;            \/\/ Client's port$/;"	m	struct:mg_connection	access:public
remove_directory	mongoose.c	/^static int remove_directory(const char *dir) {$/;"	f	file:	signature:(const char *dir)
remove_double_dots_and_double_slashes	mongoose.c	/^static void remove_double_dots_and_double_slashes(char *s) {$/;"	f	file:	signature:(char *s)
request	mongoose.c	/^  char *request;$/;"	m	struct:connection	file:	access:public
request_len	mongoose.c	/^  int request_len;  \/\/ Request length, including last \\r\\n after last header$/;"	m	struct:connection	file:	access:public
request_method	mongoose.h	/^  const char *request_method; \/\/ "GET", "POST", etc$/;"	m	struct:mg_connection	access:public
result	mongoose.c	/^  struct dirent result;$/;"	m	struct:DIR	typeref:struct:DIR::dirent	file:	access:public
rol	mongoose.c	1218;"	d	file:
run_server	lib_ui.c	/^int run_server(void)$/;"	f	signature:(void)
run_server	lib_ui.h	/^void run_server();$/;"	p	signature:()
runner_setup	lib_ui.c	/^static int runner_setup(struct mg_connection *conn)$/;"	f	file:	signature:(struct mg_connection *conn)
sa	mongoose.c	/^  struct sockaddr sa;$/;"	m	union:socket_address	typeref:struct:socket_address::sockaddr	file:	access:public
scan_directory	mongoose.c	/^static int scan_directory(struct connection *conn, const char *dir,$/;"	f	file:	signature:(struct connection *conn, const char *dir, struct dir_entry **arr)
scan_setup	lib_ui.c	/^static int scan_setup(struct mg_connection *conn)$/;"	f	file:	signature:(struct mg_connection *conn)
send_authorization_request	mongoose.c	/^static void send_authorization_request(struct connection *conn) {$/;"	f	file:	signature:(struct connection *conn)
send_continue_if_expected	mongoose.c	/^static void send_continue_if_expected(struct connection *conn) {$/;"	f	file:	signature:(struct connection *conn)
send_directory_listing	mongoose.c	/^static void send_directory_listing(struct connection *conn, const char *dir) {$/;"	f	file:	signature:(struct connection *conn, const char *dir)
send_http_error	mongoose.c	/^static void send_http_error(struct connection *conn, int code) {$/;"	f	file:	signature:(struct connection *conn, int code)
send_options	mongoose.c	/^static void send_options(struct connection *conn) {$/;"	f	file:	signature:(struct connection *conn)
send_websocket_handshake	mongoose.c	/^static void send_websocket_handshake(struct mg_connection *conn,$/;"	f	file:	signature:(struct mg_connection *conn, const char *key)
send_websocket_handshake_if_requested	mongoose.c	/^static void send_websocket_handshake_if_requested(struct mg_connection *conn) {$/;"	f	file:	signature:(struct mg_connection *conn)
server	mongoose.c	/^  struct mg_server *server;$/;"	m	struct:connection	typeref:struct:connection::mg_server	file:	access:public
server_data	mongoose.c	/^  void *server_data;$/;"	m	struct:mg_server	file:	access:public
server_param	mongoose.h	/^  void *server_param;         \/\/ Parameter passed to mg_add_uri_handler()$/;"	m	struct:mg_connection	access:public
set_close_on_exec	mongoose.c	/^static void set_close_on_exec(int fd) {$/;"	f	file:	signature:(int fd)
set_default_option_values	mongoose.c	/^static void set_default_option_values(char **opts) {$/;"	f	file:	signature:(char **opts)
set_non_blocking_mode	mongoose.c	/^static void set_non_blocking_mode(sock_t sock) {$/;"	f	file:	signature:(sock_t sock)
should_keep_alive	mongoose.c	/^static int should_keep_alive(const struct mg_connection *conn) {$/;"	f	file:	signature:(const struct mg_connection *conn)
sin	mongoose.c	/^  struct sockaddr_in sin;$/;"	m	union:socket_address	typeref:struct:socket_address::sockaddr_in	file:	access:public
sin6	mongoose.c	/^  struct sockaddr_in6 sin6;$/;"	m	union:socket_address	typeref:struct:socket_address::sockaddr_in6	file:	access:public
size	mongoose.c	/^  int size;     \/\/ Buffer size$/;"	m	struct:iobuf	file:	access:public
skip	cJSON.c	/^static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}$/;"	f	file:	signature:(const char *in)
skip	mongoose.c	/^static char *skip(char **buf, const char *delimiters) {$/;"	f	file:	signature:(char **buf, const char *delimiters)
sleep	mongoose.c	71;"	d	file:
snprintf	mongoose.c	63;"	d	file:
sock_t	mongoose.c	/^typedef SOCKET sock_t;$/;"	t	file:
sock_t	mongoose.c	/^typedef int sock_t;$/;"	t	file:
sockaddr_to_string	mongoose.c	/^static void sockaddr_to_string(char *buf, size_t len,$/;"	f	file:	signature:(char *buf, size_t len, const union socket_address *usa)
socket_address	mongoose.c	/^union socket_address {$/;"	u	file:
socket_address::sa	mongoose.c	/^  struct sockaddr sa;$/;"	m	union:socket_address	typeref:struct:socket_address::sockaddr	file:	access:public
socket_address::sin	mongoose.c	/^  struct sockaddr_in sin;$/;"	m	union:socket_address	typeref:struct:socket_address::sockaddr_in	file:	access:public
socket_address::sin6	mongoose.c	/^  struct sockaddr_in6 sin6;$/;"	m	union:socket_address	typeref:struct:socket_address::sockaddr_in6	file:	access:public
socklen_t	mongoose.c	/^typedef int socklen_t;$/;"	t	file:
spool	mongoose.c	/^static int spool(struct iobuf *io, const void *buf, int len) {$/;"	f	file:	signature:(struct iobuf *io, const void *buf, int len)
ssl	mongoose.c	/^  void *ssl;                \/\/ SSL descriptor$/;"	m	union:endpoint	file:	access:public
st	mongoose.c	/^  file_stat_t st;$/;"	m	struct:dir_entry	file:	access:public
start_process	mongoose.c	/^static pid_t start_process(char *interp, const char *cmd, const char *env,$/;"	f	file:	signature:(char *interp, const char *cmd, const char *env, const char *envp[], const char *dir, sock_t sock)
start_process	mongoose.c	/^static pid_t start_process(const char *interp, const char *cmd, const char *env,$/;"	f	file:	signature:(const char *interp, const char *cmd, const char *env, const char *envp[], const char *dir, sock_t sock)
stat	mongoose.c	72;"	d	file:
state	mongoose.c	/^    uint32_t state[5];$/;"	m	struct:__anon3	file:	access:public
static_builtin_mime_types	mongoose.c	/^} static_builtin_mime_types[] = {$/;"	v	typeref:struct:__anon2	file:
static_config_options	mongoose.c	/^static const char *static_config_options[] = {$/;"	v	file:
static_month_names	mongoose.c	/^static const char *static_month_names[] = {$/;"	v	file:
status_code	mongoose.h	/^  int status_code;            \/\/ HTTP status code for HTTP error handler$/;"	m	struct:mg_connection	access:public
suffix_object	cJSON.c	/^static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}$/;"	f	file:	signature:(cJSON *prev,cJSON *item)
suggest_connection_header	mongoose.c	/^static const char *suggest_connection_header(const struct mg_connection *conn) {$/;"	f	file:	signature:(const struct mg_connection *conn)
to64	mongoose.c	107;"	d	file:
to64	mongoose.c	75;"	d	file:
to_unicode	mongoose.c	/^static void to_unicode(const char *path, wchar_t *wbuf, size_t wbuf_len) {$/;"	f	file:	signature:(const char *path, wchar_t *wbuf, size_t wbuf_len)
transfer_file_data	mongoose.c	/^static void transfer_file_data(struct connection *conn) {$/;"	f	file:	signature:(struct connection *conn)
true	lib_ui.c	7;"	d	file:
uh	mongoose.c	/^  struct uri_handler *uh;   \/\/ URI handler user function$/;"	m	union:endpoint	typeref:struct:endpoint::uri_handler	file:	access:public
uint16_t	mongoose.c	/^typedef unsigned short uint16_t;$/;"	t	file:
uint32_t	mongoose.c	/^typedef unsigned int uint32_t;$/;"	t	file:
uint64_t	mongoose.c	/^typedef unsigned __int64 uint64_t;$/;"	t	file:
uint8_t	mongoose.c	/^typedef unsigned char uint8_t;$/;"	t	file:
uri	mongoose.c	/^  char *uri;$/;"	m	struct:uri_handler	file:	access:public
uri	mongoose.h	/^  const char *uri;            \/\/ URL-decoded URI$/;"	m	struct:mg_connection	access:public
uri_handler	mongoose.c	/^struct uri_handler {$/;"	s	file:
uri_handler::handler	mongoose.c	/^  mg_handler_t handler;$/;"	m	struct:uri_handler	file:	access:public
uri_handler::link	mongoose.c	/^  struct linked_list_link link;$/;"	m	struct:uri_handler	typeref:struct:uri_handler::linked_list_link	file:	access:public
uri_handler::uri	mongoose.c	/^  char *uri;$/;"	m	struct:uri_handler	file:	access:public
uri_handlers	mongoose.c	/^  struct linked_list_link uri_handlers;$/;"	m	struct:mg_server	typeref:struct:mg_server::linked_list_link	file:	access:public
va_copy	mongoose.c	79;"	d	file:
value	mongoose.h	/^    const char *value;        \/\/ HTTP header value$/;"	m	struct:mg_connection::mg_header	access:public
vars	mongoose.c	/^  const char *vars[MAX_CGI_ENVIR_VARS]; \/\/ char *envp[]$/;"	m	struct:cgi_env_block	file:	access:public
vec	mongoose.c	/^struct vec {$/;"	s	file:
vec::len	mongoose.c	/^  int len;$/;"	m	struct:vec	file:	access:public
vec::ptr	mongoose.c	/^  const char *ptr;$/;"	m	struct:vec	file:	access:public
vsnprintf	mongoose.c	64;"	d	file:
write_to_client	mongoose.c	/^static void write_to_client(struct connection *conn) {$/;"	f	file:	signature:(struct connection *conn)
wsbits	mongoose.h	/^  unsigned char wsbits;       \/\/ First byte of the websocket frame$/;"	m	struct:mg_connection	access:public
